#!/usr/bin/env python
import json
import pawn_base
from apps import script_list
import sys
import re
from pathlib import Path
from typing import List
import argparse


EMULATOR_VERSION = '2.0.2'


class RunConfiguration:
    def __init__(self, interpreter_id: int, script_format_id: int, name: str, version: str, executable: str, sprite_path: str, sprites: List[str], sound_path: str, sounds: List[str]) -> None:
        """
        :param interpreter_id: PAWN=0, WASM=1
        :param script_format_id: SOURCE=0, BINARY=1
        :param name:
        :param version:
        :param executable:
        :param sprite_path:
        :param sprites:
        :param sound_path:
        :param sounds:
        """
        super().__init__()
        self.interpreter_id = interpreter_id
        self.script_format_id = script_format_id
        self.name = name
        self.version = version
        self.executable = executable
        self.sprite_path = sprite_path
        self.sprites = sprites
        self.sound_path = sound_path
        self.sounds = sounds

    def to_json(self):
        return json.dumps(self, default=lambda o: o.__dict__)

    def to_dict(self):
        return json.loads(self.to_json())


def scripts_to_run_configurations(scripts: List[pawn_base.PawnModule]) -> List:
    """
    :param scripts: accepts script_list from apps.py
    """
    run_configurations = []
    for script in scripts:
        if script.ScriptFileName is None:
            continue
        if isinstance(script, pawn_base.WasmModule):
            script_format_id = 1  # BINARY
            path = script.ScriptFileName
        else:
            script_format_id = 0  # SOURCE
            path = str(Path(script.ScriptFileName).with_suffix('.pwn'))
        rc = RunConfiguration(
            interpreter_id=script.InterpreterId,
            script_format_id=script_format_id,
            name=script.name,
            version=script.version,
            executable=path,
            sprite_path=script.ScriptResourcePath,
            sprites=script.ScriptResourceList,
            sound_path=script.SoundPath,
            sounds=script.SoundList
        )
        run_configurations.append(rc.to_dict())
    return run_configurations


def generate_nopython(output: str) -> None:
    """
    For users that have no python, or have troubles with setting up python, or if they just wanted to try Emulator.
    It generates .bat and .sh files that can replicate the output of some executable.

    :param output: what to save to nopython script
    """
    nopython_bat = Path(__file__).with_name('nopython.bat')
    nopython_sh = Path(__file__).with_name('nopython.sh')
    try:
        generate_nopython_bat(nopython_bat, output)
    except PermissionError as e:
        print(f'Error: can not open file "{nopython_bat}" for writing', file=sys.stderr)
    try:
        generate_nopython_sh(nopython_sh, output)
    except PermissionError as e:
        print(f'Error: can not open file "{nopython_sh}" for writing', file=sys.stderr)


def generate_nopython_bat(path: Path, output: str) -> int:
    """
    :param path: where to save nopython.bat
    :param output: what to save to nopython.bat
    :return: 0 if success, other if failure
    """
    with path.open("w") as f:
        # Escape all Batch special symbols
        o = re.sub('(["\\\&|><^])', "^\\1", output)
        f.write("@ECHO OFF\n")
        f.write("REM This file is generated by emulator.py\n")
        for line in o.split("\n"):
            # Do not ECHO nothing
            if line.strip() == "":
                continue
            # Check for batch echo limitation
            if len(line) > 192:
                print("Configuration failed, too long line length ("+str(len(line))+" > 192)", file=sys.stderr)
                return 1
            f.write("ECHO "+line+"\n")
    return 0


def generate_nopython_sh(path: Path, output: str) -> int:
    """
    :param path: where to save nopython.sh
    :param output: what to save to nopython.sh
    :return: 0 if success, other if failure
    """
    with path.open("w", newline="\n") as f:
        # Remove any CR symbol from json
        o = output.replace("\r", "")
        f.write("#!/usr/bin/env bash\n")
        f.write("# This file is generated by emulator.py\n")
        f.write("cat <<'EOF' | cat\n")
        f.write(o)
        f.write("\nEOF\n")
    return 0


def get_run_configurations() -> str:
    """
    Returns script list as json loadable text.
    """
    run_configurations = scripts_to_run_configurations(script_list)
    output = json.dumps(run_configurations, sort_keys=True, indent=2)

    # This is test string
    _output = """[
  {
    "executable": "cut_the_rope.pwn",
    "name": "Cut_the_rope",
    "sound_path": "",
    "sounds": [],
    "sprite_path": "cuttherope",
    "sprites": [
      "000.png",
      "001.png",
      "\&|><^008.png"
    ]
  }
]"""
    return output


def get_modules_path(relative_to: Path) -> List[Path]:
    """
    Returns python modules path relative to another path
    """
    import inspect

    imported_files: List[Path] = []
    modules = sys.modules.values()  # get list of all imported modules
    relative_to = relative_to.resolve()
    for module in modules:
        try:
            module_path_str: str = inspect.getfile(module)  # raises TypeError
            module_path = Path(module_path_str)
            try:
                imported_files.append(module_path.relative_to(relative_to))
            except ValueError:
                # Path is not relative to another
                pass
        except TypeError as e:
            # Skip built-in modules
            pass
    return imported_files


def main() -> int:
    parser = argparse.ArgumentParser(description='Emulator Run Configurations generator')
    # parser.add_argument('--nopython', dest='nopython', default=True, action=argparse.BooleanOptionalAction, help='Generate nopython files')  # Python 3.9
    parser.add_argument('--nopython', dest='nopython', action='store_true', help='Generate nopython files (default: False)')
    parser.add_argument('--no-nopython', dest='nopython', action='store_false', help='')
    parser.set_defaults(nopython=False)
    parser.add_argument('-i', '--imports', dest='imports', action='store_true', help=f'Get a list of imported modules relative to the parent directory of the current file')
    parser.add_argument('-v', '--version', dest='version', action='store_true', help='Print script version and exit')
    args = parser.parse_args()

    if args.version:
        print(f"Emulator v{EMULATOR_VERSION}")
    elif args.imports:
        imported_files = get_modules_path(Path(__file__).parent)
        for files in imported_files:
            print(files, end='\n')
    else:
        output = get_run_configurations()
        if args.nopython:
            generate_nopython(output)
        print(output)

    return 0


if __name__ == '__main__':
    sys.exit(main())
